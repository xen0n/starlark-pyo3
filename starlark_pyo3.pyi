from typing import Self

# starlark::codemap

class CodeMap:
    def __init__(self, filename: str, source: str) -> None: ...
    # TODO: empty_static
    def full_span(self) -> Span: ...
    def file_span(self, span: Span) -> FileSpan: ...
    @property
    def filename(self) -> str: ...
    def byte_at(self, pos: Pos) -> int: ...
    def find_line(self, pos: Pos) -> int: ...
    @property
    def source(self) -> str: ...
    def source_span(self, span: Span) -> str: ...
    def line_span(self, line: int) -> Span: ...
    def line_span_opt(self, line: int) -> Span | None: ...
    def resolve_span(self, span: Span) -> ResolvedSpan: ...
    def source_line(self, line: int) -> str: ...
    def source_line_at_pos(self, pos: Pos) -> str: ...

class FileSpan:
    def __init__(self, filename: str, source: str) -> None: ...
    @property
    def file(self) -> CodeMap: ...
    @property
    def span(self) -> Span: ...
    @property
    def filename(self) -> str: ...
    @property
    def source_span(self) -> str: ...
    def resolve_span(self) -> ResolvedSpan: ...
    def resolve(self) -> ResolvedFileSpan: ...

class Pos:
    def __init__(self, x: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def get(self) -> int: ...
    def __int__(self) -> int: ...
    def __add__(self, other: int) -> Self: ...
    def __iadd__(self, other: int) -> None: ...

class ResolvedFileLine:
    file: str
    line: int
    def __init__(self, file: str, line: int) -> None: ...
    def __eq__(self, other: object) -> bool: ...

class ResolvedFileSpan:
    file: str
    span: ResolvedSpan
    def __init__(self, file: str, span: ResolvedSpan) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    def begin_file_line(self) -> ResolvedFileLine: ...

class ResolvedPos:
    def __init__(self, line: int, column: int) -> None: ...
    @property
    def line(self) -> int: ...
    @property
    def column(self) -> int: ...

class ResolvedSpan:
    def __init__(self, begin: ResolvedPos, end: ResolvedPos) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def begin(self) -> ResolvedPos: ...
    @property
    def end(self) -> ResolvedPos: ...
    def __contains__(self, pos: ResolvedPos) -> bool: ...
    def contains(self, pos: ResolvedPos) -> bool: ...

class Span:
    def __init__(self, begin: Pos, end: Pos) -> None: ...
    def __eq__(self, other: object) -> bool: ...
    @property
    def begin(self) -> Pos: ...
    @property
    def end(self) -> Pos: ...
    def merge(self, other: Self) -> Self: ...
    # TODO: merge_all
    def end_span(self) -> Self: ...
    def __contains__(self, pos: Pos | int) -> bool: ...
    def contains(self, pos: Pos | int) -> bool: ...

# starlark::syntax

class DialectTypes:
    pass

class Dialect:
    enable_def: bool
    enable_lambda: bool
    enable_load: bool
    enable_keyword_only_arguments: bool
    enable_types: DialectTypes
    enable_load_reexport: bool
    enable_top_level_stmt: bool
    enable_f_strings: bool
    def __init__(
        self,
        enable_def=False,
        enable_lambda=False,
        enable_load=False,
        enable_keyword_only_arguments=False,
        enable_types=DialectTypes.DISABLE,
        enable_load_reexport=False,
        enable_top_level_stmt=False,
        enable_f_strings=False,
    ) -> None: ...
    EXTENDED: Dialect
    STANDARD: Dialect

class AstLoad:
    @property
    def span(self) -> FileSpan: ...
    @property
    def module_id(self) -> str: ...
    @property
    def symbols(self) -> dict[str, str]: ...

class AstModule:
    @staticmethod
    def parse_file(path: str, dialect: Dialect = Dialect.STANDARD) -> AstModule: ...
    @staticmethod
    def parse(
        filename: str,
        content: str,
        dialect: Dialect = Dialect.STANDARD,
    ) -> AstModule: ...
    @property
    def loads(self) -> list[AstLoad]: ...
    def file_span(self, x: Span) -> FileSpan: ...
    @property
    def stmt_locations(self) -> list[FileSpan]: ...
    def replace_binary_operators(self, replace: dict[str, str]) -> None: ...
